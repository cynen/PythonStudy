**排序与搜索**
排序算法（英语：Sorting algorithm）:
    是一种能将一串数据依照特定顺序进行排列的一种算法。

排序算法的稳定性
**稳定性**：
    稳定排序算法会让原本有相等键值的纪录维持相对次序。也就是如果一个排序算法是稳定的，当有两个相等键值的纪录R和S，且在原本的列表中R出现在S之前，在排序过的列表中R也将会是在S之前。
    不稳定排序算法可能会在相等的键值中改变纪录的相对次序，但是稳定排序算法从来不会如此。不稳定排序算法可以被特别地实现为稳定。



排序算法:
1.冒泡排序 (Bubble Sort)
    两两比较,较大者后移.
    最优时间复杂度：O(n) （表示遍历一次发现没有任何可以交换的元素，排序结束。）
    最坏时间复杂度：O(n*n)
    稳定性：稳定
    
    冒泡排序算法的运作如下：
    比较相邻的元素。如果第一个比第二个大（升序），就交换他们两个。
    对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。
    针对所有的元素重复以上的步骤，除了最后一个。
    持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。
    
    
    
    
    
2.选择排序(Selection sort)
    -- 记录元素的索引位置,进行操作 .
    将待排序的列表分为前后2部分(重点关注未排序)
    [已排序    未排序]
    时间复杂度
    最优时间复杂度：O(n2)
    最坏时间复杂度：O(n2)
    稳定性：不稳定（考虑升序每次选择最大的情况）
    
    选择排序的主要优点与数据移动有关。如果某个元素位于正确的最终位置上，则它不会被移动。
    它的工作原理如下:
    首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，
    然后，再从剩余未排序元素中继续寻找最小（大）元素，
    然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。
    
    
3.插入排序(Insertion Sort)
    是一种简单直观的排序算法。
    它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。
    插入排序在实现上，在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。

    时间复杂度
    最优时间复杂度：O(n) （升序排列，序列已经处于升序状态）
    最坏时间复杂度：O(n2)
    稳定性：稳定


4.快速排序(Quicksort)
    快速排序（英语：Quicksort），
    又称划分交换排序（partition-exchange sort），通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。
    使用递归.
    时间复杂度
    最优时间复杂度：O(nlogn)
    最坏时间复杂度：O(n2)
    稳定性：不稳定
5.希尔排序(Shell Sort)
    希尔排序的基本思想是：将数组列在一个表中并对列分别进行插入排序，重复这过程，不过每次用更长的列（步长更长了，列数更少了）来进行。最后整个表就只有一列了。将数组转换至表是为了更好地理解这算法，算法本身还是使用数组进行排序。 
    
    
6.归并排序(MergeSort)
    归并排序是采用分治法的一个非常典型的应用。
    归并排序的思想就是先递归分解数组，再合并数组。
    将数组分解最小之后，然后合并两个有序数组，基本思路是比较两个数组的最前面的数，谁小就先取谁，取了后相应的指针就往后移一位。然后再比较，直至一个数组为空，最后把另一个数组的剩余部分复制过来即可。

7.常见排序算法效率比较

搜索：




